- EJERCICIO 2 -

La función goes_before() recibe 2 enteros y te retorna un booleano que dice si el primer elemento es menor que el segundo de acuerdo a su valor absoluto.

---

- EJERCICIO 4 -

RESULTADOS:

-UNSORTED-100000:

statistics for selection_sort
time elapsed = 27420.5, comparisons: 704982704, swaps: 100000

statistics for insertion_sort
time elapsed = 35798.1, comparisons: 2498635594, swaps: 2498535610

statistics for quick_sort
time elapsed = 32.365, comparisons: 3547068, swaps: 360595

SORTED-DESC-10000:

statistics for selection_sort
time elapsed = 357.913, comparisons: 49995000, swaps: 10000

statistics for insertion_sort
time elapsed = 717.392, comparisons: 49995000, swaps: 49995000

statistics for quick_sort
time elapsed = 411.248, comparisons: 74990000, swaps: 9999

SORTED-ASC-10000:

statistics for selection_sort
time elapsed = 287.392, comparisons: 49995000, swaps: 10000

statistics for insertion_sort
time elapsed = 0.143, comparisons: 10398, swaps: 399

statistics for quick_sort
time elapsed = 526.107, comparisons: 96110645, swaps: 9626

CONCLUSIÓN:
Para arreglos desordenados el quick_sort es ampliamente superior y a mas aumenta la cantidad a ordenar mas hace la diferencia en tiempo.

Para arreglos ordenados el insertion_sort fue mucho mejor.

Para arreglos ordenados al reves selection_sort y quick_sort tardaron parecido, al insertion_sort parece que le costo notoriamente mas. Creo que si el arreglo fuera mas grande eventualmente el quick_sort le sacaria mucha ventaja al selection_sort.

---
